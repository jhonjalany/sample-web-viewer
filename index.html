<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>EyeStrike ‚Äî Shoot with Eyes, Mouse, or Keyboard</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      color: white;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
    }

    #intro {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      text-align: center;
      z-index: 10;
      background: rgba(0,0,0,0.85);
      padding: 1rem;
    }
    #intro h1 { font-size: 2.5rem; margin-bottom: 1rem; color: #0af; }
    #intro p { font-size: 1.2rem; max-width: 80%; margin-bottom: 1.5rem; line-height: 1.5; }
    #startBtn {
      padding: 12px 32px; font-size: 1.2rem; background: #0af; color: white;
      border: none; border-radius: 50px; cursor: pointer;
      transition: background 0.3s;
    }
    #startBtn:hover { background: #08c; }
    #permError { 
      color: #f55; margin-top: 1rem; 
      max-width: 80%; line-height: 1.4;
    }

    #game {
      position: relative;
      width: 100vw; height: 100vh;
    }

    #video, #overlay {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; }
    #overlay { z-index: 2; pointer-events: none; }

    #crosshair {
      position: absolute;
      width: 24px; height: 24px;
      border: 2px solid cyan;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 5;
      display: none;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    /* Subtle aiming circle for mouse/touch */
    #crosshair::after {
      content: '';
      position: absolute;
      top: 50%; left: 50%;
      width: 12px; height: 12px;
      border: 1px solid rgba(0, 200, 255, 0.5);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
      transition: opacity 0.3s;
    }

    /* Show inner dot only in mouse/touch mode */
    #crosshair[style*="display: none"]::after,
    #crosshair[style*="display: block"]::after {
      opacity: 0;
    }

    #crosshair:not([style*="display: none"]):not([style*="display: block"])::after,
    #crosshair[style*="display: "]::after {
      opacity: 1;
    }

    #ui {
      position: absolute; top: 10px; left: 10px; z-index: 6;
      font-family: monospace;
      font-size: 1.1rem;
    }
    #inputMode { 
      position: absolute; top: 10px; right: 10px;
      background: rgba(0,0,0,0.6); padding: 4px 10px; border-radius: 4px;
      font-size: 0.9rem;
    }

    .enemy {
      position: absolute;
      width: 40px; height: 40px;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%23ff4444"/><rect x="40" y="20" width="20" height="60" fill="%238b0000"/></svg>');
      background-size: contain;
      z-index: 3;
    }

    .explosion {
      position: absolute;
      width: 60px; height: 60px;
      background: radial-gradient(circle, #ffff00, #ff8800, transparent);
      border-radius: 50%;
      pointer-events: none;
      z-index: 4;
      animation: explode 0.4s forwards;
    }
    @keyframes explode {
      0% { transform: scale(0.3); opacity: 1; }
      100% { transform: scale(2); opacity: 0; }
    }

    #hint {
      position: absolute; bottom: 20px; width: 100%; text-align: center;
      background: rgba(0,0,0,0.7); padding: 8px; font-size: 1rem;
      z-index: 7;
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="intro">
    <h1>üëÅÔ∏è EyeStrike</h1>
    <p>Look to aim. Blink or stare to shoot.<br>
       No camera? Use mouse, touch, or press SPACE!</p>
    <button id="startBtn">üöÄ Start Game</button>
    <div id="permError" class="hidden"></div>
  </div>

  <div id="game" class="hidden">
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>
    <div id="crosshair"></div>
    <div id="ui">
      <div>Score: <span id="score">0</span></div>
      <div>Enemies: <span id="enemyCount">0</span></div>
    </div>
    <div id="inputMode">üñ±Ô∏è Mouse</div>
    <div id="hint" class="hidden"></div>
  </div>

  <!-- TensorFlow.js + Face Landmarks (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.2"></script>

  <script>
    // ===== CONFIG =====
    const BLINK_THRESHOLD = 0.18;
    const DWELL_TIME_MS = 1000;
    const SHOOT_COOLDOWN = 200;

    // ===== STATE =====
    let model;
    let video, canvas, ctx, crosshair;
    let gameActive = false;
    let aimX = window.innerWidth / 2;
    let aimY = window.innerHeight / 2;
    let score = 0;
    let enemies = [];
    let blinkDetected = false;
    let lastBlink = 0;
    let dwellStart = null;
    let lastShoot = 0;
    let inputMode = 'mouse'; // 'eye', 'mouse', 'touch'
    let eyeControlActive = false;

    // ===== DOM =====
    const intro = document.getElementById('intro');
    const game = document.getElementById('game');
    const startBtn = document.getElementById('startBtn');
    const permError = document.getElementById('permError');
    const scoreEl = document.getElementById('score');
    const enemyCountEl = document.getElementById('enemyCount');
    const inputModeEl = document.getElementById('inputMode');
    const hintEl = document.getElementById('hint');

    // ===== UTILS =====
    function isTouchDevice() {
      return ('ontouchstart' in window) || 
             (navigator.maxTouchPoints > 0) ||
             (navigator.msMaxTouchPoints > 0);
    }

    function showHint(text) {
      hintEl.textContent = text;
      hintEl.classList.remove('hidden');
      setTimeout(() => hintEl.classList.add('hidden'), 3000);
    }

    function setInputMode(mode) {
      inputMode = mode;
      inputModeEl.textContent = 
        mode === 'eye' ? 'üëÅÔ∏è Eyes' :
        mode === 'touch' ? 'üëÜ Touch' : 'üñ±Ô∏è Mouse';
      crosshair.style.display = mode === 'eye' ? 'block' : 'none';
    }

    // ===== INIT =====
    startBtn.onclick = async () => {
      try {
        await loadModel();
        await setupAndTryEyeControl();
      } catch (e) {
        console.error("Eye control setup failed:", e);
        // Distinguish error types for better UX
        if (e.name === 'NotAllowedError') {
          permError.textContent = "‚ö†Ô∏è Camera access was denied. Using mouse/touch.";
        } else if (e.name === 'NotFoundError' || e.message.includes('no devices')) {
          permError.textContent = "‚ö†Ô∏è No camera found. Using mouse/touch.";
        } else {
          permError.textContent = "‚ö†Ô∏è Eye control unavailable. Using mouse/touch.";
        }
        permError.classList.remove('hidden');
        initFallbackMode(); // ‚úÖ Initialize fallback early
      }

      // Enter game state
      gameActive = true;
      score = 0;
      enemies = [];
      scoreEl.textContent = score;
      enemyCountEl.textContent = enemies.length;
      intro.classList.add('hidden');
      game.classList.remove('hidden');
    };

    async function loadModel() {
      model = await faceLandmarksDetection.load(
        faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,
        { maxFaces: 1 }
      );
    }

    async function setupAndTryEyeControl() {
      video = document.getElementById('video');
      canvas = document.getElementById('overlay');
      crosshair = document.getElementById('crosshair');
      ctx = canvas.getContext('2d');

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width: 640, height: 480 },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        if (video.requestFullscreen) {
          video.requestFullscreen().catch(() => {});
        }

        setInputMode('eye');
        eyeControlActive = true;
        showHint("üëÅÔ∏è Look to aim. Blink or stare 1s to shoot!");
        gameLoop();
      } catch (err) {
        console.warn("Camera setup failed:", err);
        throw err;
      }
    }

    // ‚úÖ Fallback initialization (mouse/touch/keyboard)
    function initFallbackMode() {
      setInputMode(isTouchDevice() ? 'touch' : 'mouse');
      eyeControlActive = false;
      video.style.display = 'none';
      canvas.style.display = 'none';

      // Center aim on start
      aimX = window.innerWidth / 2;
      aimY = window.innerHeight / 2;

      // Start appropriate game loop
      if (inputMode === 'mouse' || inputMode === 'touch') {
        simpleGameLoop();
      }

      showHint(inputMode === 'touch' 
        ? "üëÜ Tap & hold (‚â•0.3s) or double-tap to shoot"
        : "üñ±Ô∏è Click or press SPACE to shoot"
      );
    }

    // ===== INPUT HANDLERS =====
    // Mouse
    document.addEventListener('mousemove', (e) => {
      if (inputMode === 'mouse') {
        aimX = e.clientX;
        aimY = e.clientY;
      }
    });
    document.addEventListener('mousedown', (e) => {
      if (inputMode === 'mouse') {
        e.preventDefault();
        triggerShoot();
      }
    });

    // Keyboard (Space to shoot)
    document.addEventListener('keydown', (e) => {
      if (gameActive && inputMode === 'mouse' && e.code === 'Space') {
        e.preventDefault();
        triggerShoot();
      }
    });

    // Touch
    let lastTap = 0;
    document.addEventListener('touchstart', (e) => {
      if (inputMode === 'touch') {
        e.preventDefault();
        const t = e.touches[0];
        aimX = t.clientX;
        aimY = t.clientY;
        const now = Date.now();
        if (now - lastTap <= 300) {
          triggerShoot(); // double-tap
        }
        lastTap = now;
        dwellStart = now;
      }
    });
    document.addEventListener('touchmove', (e) => {
      if (inputMode === 'touch') {
        e.preventDefault();
        const t = e.touches[0];
        aimX = t.clientX;
        aimY = t.clientY;
      }
    });
    document.addEventListener('touchend', (e) => {
      if (inputMode === 'touch') {
        e.preventDefault();
        if (dwellStart && Date.now() - dwellStart > 300) {
          triggerShoot(); // long press
        }
        dwellStart = null;
      }
    });

    function triggerShoot() {
      const now = Date.now();
      if (now - lastShoot > SHOOT_COOLDOWN) {
        lastShoot = now;
        fireAt(aimX, aimY);
      }
    }

    // ===== GAZE & BLINK (Eye Mode) =====
    function estimateGaze(landmarks) {
      const leftOuter = landmarks[263];
      const leftInner = landmarks[362];
      const rightOuter = landmarks[33];
      const rightInner = landmarks[133];
      const nose = landmarks[1];
      const forehead = landmarks[10];
      const chin = landmarks[152];

      const leftEyeWidth = Math.abs(leftOuter.x - leftInner.x);
      const rightEyeWidth = Math.abs(rightOuter.x - rightInner.x);
      const asymmetry = (rightEyeWidth - leftEyeWidth) / (leftEyeWidth + rightEyeWidth + 1e-5);
      const earMidX = (landmarks[234].x + landmarks[454].x) / 2;
      const headYaw = (nose.x - earMidX) / 80;
      let x = 0.5 + (asymmetry * 0.3 + headYaw * 0.7) * 0.4;
      x = Math.min(0.95, Math.max(0.05, x));

      const faceHeight = chin.y - forehead.y;
      const noseRelY = (nose.y - forehead.y) / faceHeight;
      let y = 0.4 + (noseRelY - 0.5) * 1.2;
      y = Math.min(0.85, Math.max(0.15, y));

      aimX = x * window.innerWidth;
      aimY = y * window.innerHeight;
    }

    function getEAR([top, bot, outer, inner]) {
      const v = Math.hypot(top.x - bot.x, top.y - bot.y);
      const h = Math.hypot(outer.x - inner.x, outer.y - inner.y);
      return v / (h + 1e-6);
    }

    function detectBlink(landmarks) {
      const leftEAR = getEAR([
        landmarks[386], landmarks[374],
        landmarks[263], landmarks[362]
      ]);
      const rightEAR = getEAR([
        landmarks[159], landmarks[145],
        landmarks[33], landmarks[133]
      ]);
      return (leftEAR + rightEAR) / 2 < BLINK_THRESHOLD;
    }

    // ===== GAME LOGIC =====
    function fireAt(x, y) {
      // Visual feedback
      const flash = document.createElement('div');
      flash.className = 'explosion';
      flash.style.left = (x - 30) + 'px';
      flash.style.top = (y - 30) + 'px';
      document.body.appendChild(flash);
      setTimeout(() => flash?.remove(), 400);

      // Hit detection
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = (e.x + 20) - x;
        const dy = (e.y + 20) - y;
        if (dx * dx + dy * dy < 1600) {
          e.el.remove();
          enemies.splice(i, 1);
          score += 10;
          scoreEl.textContent = score;
          enemyCountEl.textContent = enemies.length;
          break;
        }
      }
    }

    function spawnEnemies() {
      if (Math.random() < 0.02 && enemies.length < 8) {
        const enemy = document.createElement('div');
        enemy.className = 'enemy';
        const side = Math.random() > 0.5 ? 'left' : 'right';
        enemy.style.left = side === 'left' ? '-50px' : (window.innerWidth + 10) + 'px';
        enemy.style.top = Math.random() * (window.innerHeight - 60) + 'px';
        document.body.appendChild(enemy);

        const speed = 1 + Math.random() * 2;
        const dirX = side === 'left' ? speed : -speed;
        const dirY = (Math.random() - 0.5) * 1;
        enemies.push({
          el: enemy,
          x: parseFloat(enemy.style.left),
          y: parseFloat(enemy.style.top),
          dx: dirX,
          dy: dirY
        });
        enemyCountEl.textContent = enemies.length;
      }
    }

    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.x += e.dx;
        e.y += e.dy;
        e.el.style.left = e.x + 'px';
        e.el.style.top = e.y + 'px';

        if (e.x < -60 || e.x > window.innerWidth + 60 || 
            e.y < -60 || e.y > window.innerHeight + 60) {
          e.el.remove();
          enemies.splice(i, 1);
          enemyCountEl.textContent = enemies.length;
        }
      }
    }

    // ===== LOOPS =====
    async function gameLoop() {
      if (!gameActive) return;

      try {
        const predictions = await model.estimateFaces({ input: video });
        if (predictions.length > 0) {
          const lms = predictions[0].keypoints;
          estimateGaze(lms);
          const blinking = detectBlink(lms);
          const now = Date.now();

          crosshair.style.left = aimX + 'px';
          crosshair.style.top = aimY + 'px';

          if (blinking && !blinkDetected && (now - lastBlink) > 300) {
            blinkDetected = true;
            lastBlink = now;
            triggerShoot();
          } else if (!blinking) {
            blinkDetected = false;
          }

          if (!blinking) {
            if (dwellStart === null) dwellStart = now;
            else if (now - dwellStart > DWELL_TIME_MS) {
              dwellStart = null;
              triggerShoot();
            }
          } else {
            dwellStart = null;
          }
        }
      } catch (e) {
        console.error("Face detection error:", e);
        if (eyeControlActive) {
          eyeControlActive = false;
          showHint("üëÅÔ∏è Eye control lost. Switched to mouse.");
          setInputMode('mouse');
          // Give time for state to settle
          setTimeout(() => {
            if (gameActive && !eyeControlActive) simpleGameLoop();
          }, 100);
          return;
        }
      }

      spawnEnemies();
      updateEnemies();
      requestAnimationFrame(gameLoop);
    }

    function simpleGameLoop() {
      if (!gameActive || eyeControlActive) return;

      crosshair.style.left = aimX + 'px';
      crosshair.style.top = aimY + 'px';

      spawnEnemies();
      updateEnemies();
      requestAnimationFrame(simpleGameLoop);
    }

    // ===== CLEANUP & RESIZE =====
    window.addEventListener('beforeunload', () => {
      gameActive = false;
      const stream = video?.srcObject;
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    });

    window.addEventListener('resize', () => {
      if (!gameActive) return;
      aimX = Math.min(aimX, window.innerWidth - 1);
      aimY = Math.min(aimY, window.innerHeight - 1);
    });
  </script>
</body>
</html>
